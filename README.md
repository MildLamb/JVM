# JVM
## JVM 体系结构
![image](https://user-images.githubusercontent.com/92672384/158717980-7432027f-eefd-42e3-820d-f2bde3164683.png)

## 类加载器和双亲委派机制
![{{}FV6ZC{QX3L_JSX 610F4](https://user-images.githubusercontent.com/92672384/158719714-80892a29-8811-43be-a4fc-58994cd219eb.png)

![image](https://user-images.githubusercontent.com/92672384/158723202-bc487064-cda1-42fd-a2b3-b980907e6a95.png)

- 双亲委派：双亲委派机制时JVM类加载的默认使用的机制，其原理是:当一个类加载器收到类加载任务时，会先交给自己的父加载器去完成，因此最终加载任务都会传递到最顶层的BootstrapClassLoader，只有当父加载器无法完成加载任务时，才会按照由父级到子集的顺序尝试自己来加载。

### 程序计数器:Program Counter Register
- 每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码（用来存储指向下一条指令的地址，也就是即将要执行的指令代码），在执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。

### 方法区：Method Area
- 方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法，如构造函数，接口代码也在此定义，简单说，所有定义的方法的信息都保存在该区域，此区域属于共享区；
- 静态常量(static)，常量(final)，类信息(构造方法，接口定义)，运行时的常量池存在方法区中，但实际变量存在堆内存中，和方法区无关

### 栈：stack
- 线程结束，栈内存也就释放了，对于栈来说，不存在垃圾回收问题  
- 存放基本类型的变量数据和对象的引用


**栈运行原理：栈帧**  
栈帧(Stack Frame)   
- 栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构。它是虚拟机运行时数据区中的java虚拟机栈的栈元素。
- 栈帧存储了方法的 局部变量表、操作数栈、动态连接和方法返回地址 等信息。
- 每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机里面从入栈到出栈的过程。

![image](https://user-images.githubusercontent.com/92672384/159100281-5bb96f23-c40f-45f7-8355-363829d567fd.png)

### 堆：Heap
- Heap，一个JVM只有一个堆内存，堆内存的大小是可以调节的。  
- 堆内存细分为3个区域
  - 新生区
    - 伊甸园区，所有的对象都是在伊甸园区new出来的
    - 幸存者区(0,1)
  - 老年区
  - 永久区
- 对象在伊甸园放不下将会执行一次轻GC，清理幸存区直到能放下对象，如果幸存区清理不出来，任然放不下对象，则会发生重GC，将清理幸存者区并且将幸存区存活下来的对象移到养老区，如果清理过后幸存区域任然放不下对象，则重GC会将对象直接放在养老区中，如果养老区也不足以放下该对象，则会产生OOM。


## GC
- GC两种类型：minor gc，full gc
- 四大算法应该为：复制算法，标记整理算法，标记清除算法，分代收集算法

### 复制算法
**思想**：将内存空间分为两块相同的存储空间，每次只使用一块，GC时，将正在使用的内存中的存活对象复制到另一块存储空间中，然后清除正在使用的空间的所有对象  

**优点**：存活对象相对少时，效率很高（因为需要复制的对象少），存活对象复制到另一空间时，解决了空间碎片问题  

**缺点**：系统内存只能使用一半的内存空间，而且如果存活对象相对多的话，比较耗时  

**使用场景**：对象存货度较低的时候，新生区

![image](https://user-images.githubusercontent.com/92672384/159143911-9101151c-ed61-4fec-9a6d-955dd48afb98.png)
